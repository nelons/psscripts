param([String] $VIContainer,
	  [Switch] $SkipClearAnnotations = $true,
	  [Switch] $WhatIf = $false
	  )

Function GetRootFolder($vm)
{
	$current_folder = $vm.Folder;
	while ($current_folder) {
		if ($current_folder.Parent.GetType().Name -eq "DatacenterWrapper") {
			break;
		}
		
		$current_folder = $current_folder.Parent;
	}
	
	return $current_folder;
}

Function RestoreToFolder($rootFolder, $vm, $folder_string)
{
	$folders = $folder_string.Split("\");
	$current_folder = $rootFolder;
	foreach ($folder in $folders) {
		# Try and find $folder as a child of $current_folder.
		$this_folder = $current_folder.ExtensionData.ChildEntity | ? { $_.Type -eq "Folder" } | ? { (Get-Folder -Id "$($_.Type)-$($_.Value)").Name -eq $folder }
		if ($this_folder -ne $null) {
			$current_folder = Get-Folder -Id $this_folder
			
		} else {
			if ($WhatIf -eq $false) {
				$new_folder = $current_folder.ExtensionData.CreateFolder($folder)
				if ($new_folder -ne $null) {
					$current_folder = Get-Folder -Id $new_folder;
				
				} else {
					break;
				}
				
			} else {
				Write-Host "Creating folder $folder";
				
			}
		}
	}
	
	if ($current_folder -ne $null -And $current_folder -ne $vm.Folder) {
		Move-VM $vm -Destination $current_folder -WhatIf:$WhatIf | out-null
	}
}
	  
$log = New-Object System.IO.StreamWriter (($PWD.Path) + "/notesrollback-" + $logPrefix + "-" + $(get-date -format "yyyyMdd-HHmmss") + ".txt"), 1	  

## VMWare PowerCLI must be installed. Add the modules.
Add-PSSnapin VMware.VimAutomation.Core -ea SilentlyContinue

## Connect to the server.
#Connect-VIServer $VIServer | out-null

#Write-Host $VIContainer
$vms = Get-VM -Location $VIContainer
if ($vms -eq $null) {
	Write-Host "No VMs to restore.";
	Exit;
	
} elseif ($vms -isnot [system.array]) {
	$my_vm = $vms;
	$vms = @($my_vm);

}

$root_folder = GetRootFolder $vms[0]
foreach ($vm in $vms) {
	#if (-Not $vm.Name.StartsWith("lo-vpc-nlon")) {
	#	continue;
	#}	

	## Split the Notes field up by the newline character.
	$lines = $vm.Notes.Split([environment]::NewLine);
	if ($lines.Count -eq 0) { continue; }
	
	## If there is no autogenerated header then ignore this vm.
	If ($lines[0] -ne "*Auto-Gen*") { 
		$log.WriteLine("$vm : Auto-Gen header not found in Notes field. Skipping.");
		$log.Flush();
		continue; 
	}

	# Clear all the Annotations from the target VM.
	if ($SkipClearAnnotations -eq $False) {
		Get-Annotation $vm | ? { Set-Annotation -entity $vm -customattribute $_.Name -Value "" -WhatIf:$WhatIf | out-null }
	}
	
	foreach ($line in $lines) {
		# If the line starts with an asterisk then ignore this line.
		If ($line[0] -eq "*") { continue; }
			
		# Divide up this line.
		$tokens = $line.Split("=");
		If ($tokens[0] -eq "VLANS") {
		
			## Get a list of adapters
			$nics = get-networkadapter $vm | sort-object { if ($_.Name -match '(\d+)') { [int] $matches[1] } }
			if ($nics -isnot [system.array]) {
				$this_nic = $nics;
				$nics = @($this_nic);
			}
			
			## tokenise the VLAN value
			$vlans = $($tokens[1]).Split(",");
			
			## if the number of adapters doesn't match the number of VLANS then throw an error
			if ($nics.count -ne $vlans.count) {
				$log.WriteLine("$($vm.Name): The number of Ethernet adaptors on the VM ($($nics.count)) does not match the number of VLANs ($($vlans.count)) in the Notes.");
				$log.Flush();
				Write-Host "$($vm.Name): The number of Ethernet adaptors on the VM ($($nics.count)) does not match the number of VLANs ($($vlans.count)) in the Notes."
				continue;
				
			}
			
			## for each adapter
			for ($i = 0; $i -lt $nics.Count; $i++) {		
				$nic = $nics[$i];
				$vlan = $vlans[$i];			
				$vpg = $Null;
			
				## Look at assigning VLANS
				if ($vlan -eq "x") {
					## Do nothing. There is no VLAN configured here. Spit out message
					$log.WriteLine("$($vm.Name): Network Adapter $i has no configuration information.");
					$log.Flush();
					Write-Host "$($vm.Name): Network Adapter $i has no configuration information.";
					
				} else {
					if ($vlan[0] -eq "S") {
						# Standard Switch
						Write-Host "$($vm.Name) Network Adapter $i is/was on a standard switch. Doing nothing.";
					
					} else {				
						if ($vlan.IndexOf("-") -eq -1) {
							# We are looking for a single VLAN
							$vpg = Get-VirtualPortGroup | where { $_.ExtensionData.Config.DefaultPortConfig.Vlan.VlanId -eq $vlan } -erroraction silentlycontinue -ev evPort
						
						} else {
							# We are looking for a VLAN range
							$vlanRange = $vlan.Split("-")
							
							# Get the Port Group
							$vpg = Get-VirtualPortGroup | where { $_.ExtensionData.Config.DefaultPortConfig.Vlan.VlanId.Start -eq $vlanRange[0] -And $_.ExtensionData.Config.DefaultPortConfig.Vlan.VlanId.End -eq $vlanRange[1] } -erroraction silentlycontinue -ev evPort						
													
						}
					}
				}
				
				if ($vpg.Count -eq 0) {
					# No Portgroups found. write out error information.
					if ([string]::IsNullOrEmpty($evPort) -eq $False) {
						$log.WriteLine("$($vm.Name): $evPort");
						$log.Flush();
						Write-Host $evPort
						
					} else {
						$log.WriteLine("$($vm.Name): Could not find a portgroup for VLAN $vlan");
						$log.Flush();
						Write-Host "$($vm.Name): Could not find a portgroup for VLAN $vlan";
					
					}
				
				} elseif ($vpg.Count -eq 1) {
					# Got one portgroup - if not already assigned then we assign.
					if ($nic.NetworkName -ne $vpg.Name) {					
						Set-NetworkAdapter -NetworkAdapter $nic -NetworkName $vpg.Name -Confirm:$False -WhatIf:$WhatIf | out-null
								
					}
						
				} elseif ($vpg.Count -gt 1) {
					# Got more than one portgroup - inform user this is a manual process
					$log.WriteLine("$($vm.Name): Cannot set Network Adapter $i for VLAN $vlan as $($vpg.Count) portgroups were found that match this number/range.");
					$log.Flush();
					Write-Host "$($vm.Name): Cannot set Network Adapter $i for VLAN $vlan as $($vpg.Count) portgroups were found that match this number/range.";
					
				}		
			}
		
		} Elseif ($tokens[0] -eq "FolderPath") {
			RestoreToFolder $root_folder $vm $($tokens[1])

		} Elseif ($tokens[0] -ne $null -And $tokens[0].Length -gt 0) {
			#Write-Host "Looking to set '$($tokens[0])'";
			#$tokens[0].Length
		
			## look for the annotation value
			$anno = Get-Annotation -Entity $vm -CustomAttribute $tokens[0] -ea silentlycontinue -ev evGetAnno
			
			## If the value is not as 
			if ([string]::IsNullOrEmpty($evGetAnno) -And $(($anno.Value) -ne $tokens[1])) {
				$log.WriteLine("$($vm.Name): Setting $($tokens[0]) to $($tokens[1])");
				$log.Flush();
				Set-Annotation -Entity $vm -CustomAttribute $tokens[0] -Value $tokens[1] -ea silentlycontinue -ev evSetAnno -WhatIf:$WhatIf | out-null
				
				if ([string]::IsNullOrEmpty($evSetAnno) -eq $False) {
					## Log Error
					$log.WriteLine("$($vm.Name): Error setting value: $evSetAnno");
					$log.Flush();
					Write-Host "$($vm.Name): Error setting value: $evSetAnno";
				}
				
			} elseif ([string]::IsNullOrEmpty($evGetAnno) -eq $False -And $(($anno.Value) -ne $tokens[1])) {			
				# Create the custom attribute
				$log.WriteLine("$($vm.Name): Creating new annotation $($tokens[0])");
				$log.Flush();
				New-CustomAttribute -Name $tokens[0] -TargetType VirtualMachine -WhatIf:$WhatIf | out-null
				
				# Set the value
				$log.WriteLine("$($vm.Name): Setting annotation $($tokens[0]) to $($tokens[1])");
				$log.Flush();
				Set-Annotation -Entity $vm -CustomAttribute $tokens[0] -Value $tokens[1] -ea silentlycontinue -ev evSetAnno -WhatIf:$WhatIf	| out-null
			
			}
		}		
	}
	
	Write-Host "$($vm.Name): Completed";
	$log.WriteLine("$($vm.Name): Completed");
	$log.Flush();
}

$log.Close();

## Disconnect from the server.
#Disconnect-VIServer $VIServer -Confirm:$False
